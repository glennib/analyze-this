#!/usr/bin/env python3

"""
Git History Analysis Tool

Analyzes changes between two git refs across three dimensions:
1. Module coupling
2. Test coverage
3. Abstractions and concepts

Usage: ./analyze-changes <git-ref-a> <git-ref-b>
Output: JSON with scores from -5 to +5 for each dimension
"""

import os
import sys
import json
import subprocess
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, Any
import urllib.request
import urllib.error

# Configuration
ANTHROPIC_API_KEY = os.environ.get('ANTHROPIC_API_KEY')
MODEL = os.environ.get('MODEL', 'claude-sonnet-4-20250514')

SCRIPT_DIR = Path(__file__).parent.resolve()
PROMPTS_DIR = SCRIPT_DIR / 'prompts'

DIMENSIONS = [
    {'name': 'coupling', 'file': 'coupling-analysis.md'},
    {'name': 'test_coverage', 'file': 'test-coverage-analysis.md'},
    {'name': 'abstraction', 'file': 'abstraction-analysis.md'}
]


def get_git_diff(ref_a: str, ref_b: str) -> str:
    """Extract git diff between two refs"""
    try:
        result = subprocess.run(
            ['git', 'diff', f'{ref_a}..{ref_b}'],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f'Error getting git diff: {e}', file=sys.stderr)
        sys.exit(1)


def get_diff_stats(ref_a: str, ref_b: str) -> str:
    """Get file statistics from diff"""
    try:
        result = subprocess.run(
            ['git', 'diff', '--stat', f'{ref_a}..{ref_b}'],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f'Error getting diff stats: {e}', file=sys.stderr)
        sys.exit(1)


def load_prompt(prompt_file: str) -> str:
    """Load analysis prompt from file"""
    prompt_path = PROMPTS_DIR / prompt_file
    try:
        return prompt_path.read_text(encoding='utf-8')
    except Exception as e:
        print(f'Error loading prompt {prompt_file}: {e}', file=sys.stderr)
        sys.exit(1)


def analyze_dimension(dimension: str, prompt: str, diff: str, stats: str) -> Dict[str, Any]:
    """Call Claude API to analyze diff according to dimension prompt"""
    if not ANTHROPIC_API_KEY:
        print('Error: ANTHROPIC_API_KEY environment variable not set', file=sys.stderr)
        sys.exit(1)

    # Truncate diff if too long
    diff_content = diff[:50000]
    truncated_msg = '\n... (diff truncated)' if len(diff) > 50000 else ''

    analysis_prompt = f"""{prompt}

## Git Diff to Analyze

### Diff Statistics
```
{stats}
```

### Full Diff
```diff
{diff_content}{truncated_msg}
```

Please analyze this git diff according to the instructions above and return ONLY a valid JSON object in the format specified, with no additional text or markdown formatting."""

    try:
        # Prepare API request
        request_data = {
            'model': MODEL,
            'max_tokens': 4096,
            'messages': [{
                'role': 'user',
                'content': analysis_prompt
            }]
        }

        req = urllib.request.Request(
            'https://api.anthropic.com/v1/messages',
            data=json.dumps(request_data).encode('utf-8'),
            headers={
                'Content-Type': 'application/json',
                'x-api-key': ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            },
            method='POST'
        )

        with urllib.request.urlopen(req) as response:
            data = json.loads(response.read().decode('utf-8'))
            content = data['content'][0]['text']

            # Extract JSON from response (handle markdown code blocks if present)
            json_match = re.search(r'```json\s*([\s\S]*?)\s*```', content)
            if not json_match:
                json_match = re.search(r'```\s*([\s\S]*?)\s*```', content)

            json_str = json_match.group(1) if json_match else content
            result = json.loads(json_str.strip())

            return result

    except urllib.error.HTTPError as e:
        error_text = e.read().decode('utf-8')
        print(f'Error analyzing {dimension}: HTTP {e.code} - {error_text}', file=sys.stderr)
        return {
            'dimension': dimension,
            'score': 0,
            'reasoning': f'Analysis failed: HTTP {e.code}',
            'key_factors': [],
            'confidence': 'low',
            'error': True
        }
    except Exception as e:
        print(f'Error analyzing {dimension}: {e}', file=sys.stderr)
        return {
            'dimension': dimension,
            'score': 0,
            'reasoning': f'Analysis failed: {str(e)}',
            'key_factors': [],
            'confidence': 'low',
            'error': True
        }


def main():
    """Main execution"""
    # Parse arguments
    args = sys.argv[1:]

    if len(args) != 2:
        print('Usage: ./analyze-changes <git-ref-a> <git-ref-b>', file=sys.stderr)
        print('Example: ./analyze-changes main feature-branch', file=sys.stderr)
        sys.exit(1)

    ref_a, ref_b = args

    print(f'Analyzing changes from {ref_a} to {ref_b}...', file=sys.stderr)

    # Get git diff
    print('Extracting git diff...', file=sys.stderr)
    diff = get_git_diff(ref_a, ref_b)
    stats = get_diff_stats(ref_a, ref_b)

    if not diff.strip():
        print('No changes detected between the specified refs.', file=sys.stderr)
        sys.exit(1)

    # Analyze each dimension
    results = {
        'metadata': {
            'ref_a': ref_a,
            'ref_b': ref_b,
            'analyzed_at': datetime.utcnow().isoformat() + 'Z',
            'model': MODEL
        },
        'dimensions': {},
        'summary': {
            'total_score': 0,
            'average_score': 0
        }
    }

    for dimension_info in DIMENSIONS:
        name = dimension_info['name']
        file = dimension_info['file']
        print(f'Analyzing {name}...', file=sys.stderr)
        prompt = load_prompt(file)
        analysis = analyze_dimension(name, prompt, diff, stats)
        results['dimensions'][name] = analysis

    # Calculate summary
    scores = [
        d['score'] for d in results['dimensions'].values()
        if not d.get('error', False)
    ]

    results['summary']['total_score'] = sum(scores)
    results['summary']['average_score'] = (
        round(results['summary']['total_score'] / len(scores), 2)
        if scores else 0
    )

    # Output JSON
    print(json.dumps(results, indent=2))


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(f'Fatal error: {e}', file=sys.stderr)
        sys.exit(1)
